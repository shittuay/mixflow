generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id               String           @id @default(cuid())
  email            String           @unique
  username         String           @unique
  firstName        String?
  lastName         String?
  passwordHash     String
  userType         UserType         @default(LISTENER)
  subscriptionTier SubscriptionTier @default(FREE)
  isVerified       Boolean          @default(false)
  isActive         Boolean          @default(true)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  artist           Artist?
  djSessions       DJSession[]
  playlists        Playlist[]
  streams          Stream[]
  subscriptions    Subscription[]
  uploads          TrackUpload[]
  analytics        UserAnalytics[]

  @@index([email])
  @@index([username])
  @@index([subscriptionTier])
  @@map("users")
}

model Artist {
  id              String            @id @default(cuid())
  userId          String            @unique
  stageName       String
  bio             String?
  profileImageUrl String?
  coverImageUrl   String?
  isVerified      Boolean           @default(false)
  totalStreams    Int               @default(0)  // CHANGED: was BigInt
  totalEarnings   Decimal           @default(0)
  payoutInfo      Json?
  socialLinks     Json?
  genres          Json?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  albums          Album[]
  analytics       ArtistAnalytics[]
  user            User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  tracks          Track[]

  @@map("artists")
}

model Track {
  id             String           @id @default(cuid())
  artistId       String
  title          String
  description    String?
  duration       Int
  fileUrl        String
  artworkUrl     String?
  waveformUrl    String?
  genre          String
  subGenre       String?
  bpm            Int?
  keySignature   String?
  isExplicit     Boolean          @default(false)
  isPublic       Boolean          @default(true)
  uploadDate     DateTime         @default(now())
  releaseDate    DateTime?
  streamCount    Int              @default(0)  // CHANGED: was BigInt
  downloadCount  Int              @default(0)  // CHANGED: was BigInt
  status         TrackStatus      @default(PENDING)
  tags           Json?
  metadata       Json?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  albumId        String?
  djSessions     DJSessionTrack[]
  playlistTracks PlaylistTrack[]
  streams        Stream[]
  uploads        TrackUpload[]
  album          Album?           @relation(fields: [albumId], references: [id])
  artist         Artist           @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@index([artistId])
  @@index([genre])
  @@index([status])
  @@index([uploadDate])
  @@index([streamCount])
  @@map("tracks")
}

model Album {
  id          String   @id @default(cuid())
  artistId    String
  title       String
  description String?
  artworkUrl  String?
  releaseDate DateTime
  genre       String
  isPublic    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  artist      Artist   @relation(fields: [artistId], references: [id], onDelete: Cascade)
  tracks      Track[]

  @@map("albums")
}

model Stream {
  id             String   @id @default(cuid())
  userId         String
  trackId        String
  timestamp      DateTime @default(now())
  durationPlayed Int
  deviceType     String?
  platform       String?
  location       String?
  ipAddress      String?
  completed      Boolean  @default(false)
  track          Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([trackId])
  @@index([timestamp])
  @@map("streams")
}

model Playlist {
  id              String          @id @default(cuid())
  userId          String
  title           String
  description     String?
  artworkUrl      String?
  isPublic        Boolean         @default(false)
  isCollaborative Boolean         @default(false)
  trackCount      Int             @default(0)
  totalDuration   Int             @default(0)
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  tracks          PlaylistTrack[]
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("playlists")
}

model PlaylistTrack {
  id         String   @id @default(cuid())
  playlistId String
  trackId    String
  position   Int
  addedAt    DateTime @default(now())
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  track      Track    @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@unique([playlistId, trackId])
  @@map("playlist_tracks")
}

model DJSession {
  id            String           @id @default(cuid())
  userId        String
  title         String
  description   String?
  isLive        Boolean          @default(false)
  isRecording   Boolean          @default(false)
  recordingUrl  String?
  duration      Int?
  bpm           Int?
  key           String?
  listenerCount Int              @default(0)
  metadata      Json?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  tracks        DJSessionTrack[]
  user          User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("dj_sessions")
}

model DJSessionTrack {
  id            String    @id @default(cuid())
  sessionId     String
  trackId       String
  position      Int
  startTime     Int
  endTime       Int?
  crossfadeIn   Int?
  crossfadeOut  Int?
  effects       Json?
  bpmAdjustment Float?
  keyAdjustment Int?
  session       DJSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  track         Track     @relation(fields: [trackId], references: [id], onDelete: Cascade)

  @@map("dj_session_tracks")
}

model Subscription {
  id                   String             @id @default(cuid())
  userId               String
  tier                 SubscriptionTier
  status               SubscriptionStatus
  revenueCatId         String?            @unique
  stripeCustomerId     String?            @unique
  stripeSubscriptionId String?            @unique
  currentPeriodStart   DateTime
  currentPeriodEnd     DateTime
  cancelAtPeriodEnd    Boolean            @default(false)
  canceledAt           DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  payments             Payment[]
  user                 User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model Payment {
  id                    String        @id @default(cuid())
  subscriptionId        String
  amount                Decimal
  currency              String        @default("USD")
  status                PaymentStatus
  stripePaymentIntentId String?       @unique
  metadata              Json?
  createdAt             DateTime      @default(now())
  subscription          Subscription  @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@map("payments")
}

model TrackUpload {
  id           String       @id @default(cuid())
  userId       String
  trackId      String?
  filename     String
  originalName String
  fileSize     Int          @default(0)  // CHANGED: was BigInt
  mimeType     String
  uploadUrl    String
  status       UploadStatus @default(UPLOADING)
  progress     Int          @default(0)
  metadata     Json?
  errorMessage String?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  track        Track?       @relation(fields: [trackId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("track_uploads")
}

model UserAnalytics {
  id               String   @id @default(cuid())
  userId           String
  date             DateTime
  tracksPlayed     Int      @default(0)
  timeListened     Int      @default(0)
  djSessionTime    Int      @default(0)
  tracksUploaded   Int      @default(0)
  playlistsCreated Int      @default(0)
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@index([date])
  @@map("user_analytics")
}

model ArtistAnalytics {
  id              String   @id @default(cuid())
  artistId        String
  date            DateTime
  totalStreams    Int      @default(0)  // CHANGED: was BigInt
  uniqueListeners Int      @default(0)
  revenue         Decimal  @default(0)
  topCountries    Json?
  topTracks       Json?
  demographics    Json?
  artist          Artist   @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([artistId, date])
  @@index([date])
  @@map("artist_analytics")
}

model SearchQuery {
  id        String   @id @default(cuid())
  userId    String?
  query     String
  results   Int      @default(0)
  timestamp DateTime @default(now())
  metadata  Json?

  @@map("search_queries")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())

  @@map("notifications")
}

enum UserType {
  LISTENER
  ARTIST
  ADMIN
}

enum SubscriptionTier {
  FREE
  PRO
  ARTIST
}

enum TrackStatus {
  PENDING
  APPROVED
  REJECTED
  PROCESSING
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  PAST_DUE
  INCOMPLETE
  INCOMPLETE_EXPIRED
  TRIALING
  UNPAID
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  CANCELED
  REFUNDED
}

enum UploadStatus {
  UPLOADING
  PROCESSING
  COMPLETED
  FAILED
  CANCELED
}

enum NotificationType {
  TRACK_APPROVED
  TRACK_REJECTED
  NEW_FOLLOWER
  PAYMENT_RECEIVED
  SUBSCRIPTION_UPDATED
  DJ_SESSION_STARTED
  SYSTEM_ANNOUNCEMENT
}